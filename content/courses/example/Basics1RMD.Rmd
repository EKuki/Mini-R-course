---
date: "2019-05-05T00:00:00+01:00"
draft: false
linktitle: R and SNA
menu:
  example:
    name: 1. Basics
    weight: 2
summary: Basics in R adn RStudio
title: 1.Basics
type: docs
weight: 2
---

Follow along with the [power point presentation](https://github.com/EKuki/website/blob/master/content/courses/example/1.Basics_SNA%20using%20R_18March19.pptx) corresponding to this `1. Basic` section.

_**Subsection 1.1**_

[This video](https://youtu.be/b7R8Q04jdrU) provides an intro to R and RStudio that that I am skiping here, so if you are really new to R/RStudio, I would recommend you to watch it. In it, I go along this `1.1` subsection of `1. Basic`.

## How to comment and run code

To write a comment, type `#` before the sentence you want to write.
Anything to the right of a `#` in a script will be ignored by R.

> To comment on a whole paragraph, select the lines you want to comment and press at the same time on your keyboard `Ctrl` + `Shift` + `c`.

> To run: Click anywhere on the line you want to run and either 1) Click `Ctr` + `Enter` or 2) Click on `run` bottom (up right corner of Source/Script)

> If you want to run several lines, highlight them all and do as explained above.

You can get output in the Console simply by typing math in the script and running it:
```{r, echo = TRUE}
3 + 5 # Result is 8
12/2 # Result is 6 
```

##  Assign values to objects
`<-` assigns values on the right to objects on the left.
> PC: Type `Alt` and `-` at the same time. 
> Mac: `Option` and `-`

```{r, echo = TRUE}
weight_kg <- 55    # doesn't print anything, but it has created an object. You can see it in the Environment window, in RStudio.
(weight_kg <- 55)  # Putting parenthesis around the call prints the value of `weight_kg`
weight_kg          # and so does typing (or "calling") the name of the object
```

> Note that R iS cAsE SeNsItIvE!! Try typing `weight_KG`. You will see an error like this one `Error: object 'weight_KG' not found`. Note the capitalizatio of `_KG`.

You can override an object. Be careful!
```{r, echo = TRUE}
weight_kg <- 60 
weight_kg # If you call wight_kg you see that its value is now 60. You can also see this change in the Environment window.
```

**Exercise 1**: Create an object (a vector) that is half the value of weight_kg (use weight_kg <- 60) called "half_weight_kg"

```{r, echo = TRUE}
half_weight_kg <- weight_kg / 2
half_weight_kg
```

You can give whichever name you want to an object, but it is a good idea to choose something that makes sense. For example:

```{r, echo = TRUE}
beautiful_day <- weight_kg / 2
beautiful_day # A bit nonesense...
half_weight_kg
```
> End of Exercise 1

_**Subsection 1.2**_

In [this video](https://youtu.be/l7jsiDXV4yI) I go along this `1.2` subsection of `1. Basic`.
Remember to follow with the power point corresponding to this `1. Basic` section!

To "concatenate" two vectors (aka, to put them together) we use `c()`:
```{r, echo = TRUE}
both_weights<-c(weight_kg, half_weight_kg)
both_weights
```

Another example:
```{r, echo = TRUE}
mum <- "Claire"
dad<- "Pablo"
parents <- c(mum, dad)
```

**Exercise 2**: Create a vector called "daughter" with a female's name and another one called "dog" with a dog's name.

```{r, echo = TRUE}
daughter <- "Anita"
dog <- "Poppy"
```

Create a new vector called "family" with the names of all family members (use this order mum, dad, daugther, dog). 
> With R, we usually can get to the same outcome coding in different ways. My solution is usually one of many.

```{r, echo = TRUE}
family <- c(parents, daughter, dog)
family
class(family)
c(mum, dad, daughter, dog)

family_char <- c("Claire", "Pablo" , "Anita",  "Poppy")
class(family_char)
```
> End Exercise 2

## a.Vectors
```{r, echo = TRUE}
a <- c(1,2,5.3,6,-2,4) # numeric vector
b <- c("one","two","three") # character vector
ce <- c(TRUE,TRUE,TRUE,FALSE,TRUE,FALSE) #logical vector
```

### Indexing a `vector`
```{r, echo = TRUE}
ce[2] # Extract second element of `ce`
a[3] # Extract third element of a
a[1:3] # Extrat all elements between the first and the third elements, of `a`
b[c(1,3)] # Extract first and third element of `b`
```

> Note that I did not use the letter `c` to name my vector: I used `ce` instead. The choice of c as the name of a vector is a pretty bad one, as there is a command/function called `c()`! See `?c` or `help(c)`

**Exercise 3**: Extract the first element of the vector family: the `mum`.
```{r, echo = TRUE}
family[1]
```

Extract the forth element of the vector family: the `dog`.
```{r, echo = TRUE}
family[4]
```

Extract both the name of the `dad` and the `daughter` (do it at the same time -using only one command-, if possible).
```{r, echo = TRUE}
family[c(2,3)]
```
> End of Exercise 3


## b.Data frames
```{r, echo = TRUE}
Identification <- c(1,2,3,4)
Colors <- c("red", "white", "red", NA) # Note NA
Succeeded <- c(TRUE,TRUE,TRUE,FALSE)
mydata <- data.frame(Identification, Colors, Succeeded) # Join those vectors together to create a `data.frame`
mydata
names(mydata) <- c("ID","Color","Passed") # Change the variable/column names
```

### Indexing a `data.frame`
```{r, echo = TRUE}
mydata[ ,c(1:2)] # columns 1 and 2 of `mydata` data frame. All rows
```

Other ways to identify observations in a `data.frame`.
```{r, echo = TRUE}
mydata[,c("ID","Color")] # columns ID and Color from `mydata`
mydata$Passed # variable ID in the data frame
```
> The $ operator is used constantly. It retrieves/extracts a variable in a dataset.

**Exercise 4**: Create a data frame called `family_df` with two columns: `name` and `age`. For column `name`, use the previous `family` vector. For column `age`, make up ages for our family
```{r, echo = TRUE}
family
age <- c(45, 48, 10, 7)
family_df <- data.frame(family, age)
family_df
names(family_df) <- c("name","age") # variable names 
family_df
```
> End of Exercise 4

## c.Matrices
```{r, echo = TRUE}
nb_matrix<-matrix(data = 1:20, nrow=5,ncol=4) # The function `matrix()` generates 5 x 4 numeric matrix called `nb_matrix`
nb_matrix

help(matrix) # look for help of the function `matrix()`
?matrix
??matrix
?graph_from_data_frame
??graph_from_data_frame
```

Another example
```{r, echo = TRUE}
cells <- c(1,26,24,68)
mymatrix <- matrix(data = cells, nrow=2, ncol=2, byrow=TRUE)
mymatrix
```

### Indexing a `matrix` (as we did with `data.frames`)
```{r, echo = TRUE}
nb_matrix[,4] # 4th column of nb_matrix
```

**Exercise 5**: Extract the 3rd row of `nb_matrix` 
```{r, echo = TRUE}
nb_matrix[3,]
```

Extract rows 2,3,4 of columns 1,2,3 of `nb_matrix` 
```{r, echo = TRUE}
nb_matrix[2:4,1:3]
nb_matrix[c(2,3,4), c(1,2,3)]
```
> End of Exercise 5


_**Subsection 1.3**_

In [this video](https://youtu.be/bxCB1xXBYcA) I go along this `1.3` subsection of `1. Basic`.
Remember to follow with the power point corresponding to this `1. Basic` section!

## d.Lists
This is an example of a list with 4 components: a string, a numeric vector, a matrix, and a scalar :
```{r, echo = TRUE}
mylist <- list(name=c("Fred", "Lola"), mynumbers=a, mymatrix=nb_matrix, age=6.8)
mylist
```

### Indexing a list
```{r, echo = TRUE}
mylist[[2]] # 2nd component of the list
mylist[[2]][3] # Extract the third element of the 2nd component of the list
```

Other ways to identify observations in a list
```{r, echo = TRUE}
mylist[["mynumbers"]] # component named mynumbers in mylist
mylist[["mynumbers"]][3]
```

## e.Factors:
R treats factors as INTEGER vectors, where each integer corresponds to a category, or a level.
As an example, let's create the variable gender with 20 "male" entries and 30 "female" entries:
```{r, echo = TRUE}
gender <- c(rep("male",20), rep("female", 30)) 
gender
class(gender) # `class()` is a function. It tells us what type of data we are dealing with
class(mylist)
```

```{r, echo = TRUE}
gender <- factor(gender) 
gender
class(gender)
levels(gender) # R sorts levels alphabetically
```

We can change the order of the levels of a factor by:
```{r, echo = TRUE}
gender2 <- factor(gender, levels = c("male", "female"))
levels(gender2)
```
 
We can also change the levels names by renaming the factor labels:
```{r, echo = TRUE}
gender3 <-factor(gender, labels = c("red", "yellow"))
levels(gender3)
```

>Note that it is very important to maintain the same order as the order of the factor levels! To avoid confusion, you can change the order of the levels AND the names of the labels at the same time:

```{r, echo = TRUE}
gender4 <- factor(gender,
                  levels = c("male", "female"), # make male the first level
                  labels = c("hombre", "mujer")) # change label male by label hombre

str(gender) # STRUCTURE. original
str(gender2) # we changed the order of the levels
str(gender3) # we changed the label of the levels
str(gender4) # we changed both the order and the labels of the levels
# R now treats gender as a nominal variable 
summary(gender)
```

If we want an ordinal variable, we need to add the argument `ordered = TRUE`:
```{r, echo = TRUE}
quality_product <- c("G", "B", "Avg", "Avg", "Avg", "G", "B", "G", "G", "G") # G = good, Avg = average, B = bad
quality_product_f <- factor(quality_product, ordered = TRUE,
                            levels = c("B", "Avg", "G")) # Tell R that this is an ordered vector
quality_product_f # Note that B < Avg < G
str(quality_product_f)
```

## f.Functions

```{r, echo = TRUE}
family_df
str(family_df) # structure
      # Wait a second... Why is family a Factor?!
      # ?data.frame
```

Now, run and think a bit about these lines of code:
```{r, echo = TRUE}
head(family_df, 2) # First 2 rows, all columns
head(family_df) # By default, head() gives you the first 6 rows, all columns. Our dataset only has 4 rows!
summary(family_df)
dim(family_df) # dimensions. Rows and columns
```

Try running `mean(family_df)`. It doesn't work! I need to specify a column to display!
```{r, echo = TRUE}
mean(family_df$age)
sum(family_df$age)
```

Why _does_ this one work?
```{r, echo = TRUE}
mean(age)
```

Some more functions:
```{r, echo = TRUE}
heights <- c(2, 4, 4, NA, 6)
str(heights)
summary(heights)
```

```{r, echo = TRUE}
mean(heights) # ??
max(heights) # ??
mean(heights, na.rm = TRUE) # Remove NA for this arithmetic operation
max(heights, na.rm = TRUE)
```

### Do we have missing values?
```{r, echo = TRUE}
is.na(heights)
summary(is.na(heights))
```

Identify location of NAs in vector
```{r, echo = TRUE}
which(is.na(heights)) # Index, or location, 4 has an NA
```

Identify count of NAs in data frame
```{r, echo = TRUE}
sum(is.na(heights)) # We only have one NA
```

Extract those elements which are not missing values.
```{r, echo = TRUE}
!is.na(heights)  # The operator `!` in R means NO. Thus, !is.na = those that are NOT missing values. Returns logical vector
heights[!is.na(heights)] # Extract all values from heights that are not missing values
heights[c(1,2,3,5)]
```

Extract those elements which are complete cases (case=row). 
```{r, echo = TRUE}
complete.cases(heights) # returns a logical vector indicating which cases are complete. 
heights[complete.cases(heights)]

!complete.cases(heights) # You can also subset with the `!` operator to get incomplete cases.
heights[!complete.cases(heights)]
```

**Exercise 6**: Create another column for family_df called profession where you give a profession to each family member, except to the dog. 
> Tip: *assign* a new *column*

```{r, echo = TRUE}
family_df$profession <- c("researcher", "IT", "student", NA)
```

Retrieve all cases in family_df that don't have NAs.
```{r, echo = TRUE}
family_df[complete.cases(family_df), ]
```
> End of Exercise 6

Now, run and think a bit about these lines of code:
```{r, echo = TRUE}
is.na(family_df)
is.na(family_df$name)
is.na(family_df$profession)
colSums(is.na(family_df)) # Compute the total missing values in each colum
```

Another example. Recode missing values with the mean:
```{r, echo = TRUE}
        x <- c(1:4, NA, 6:7, NA) # vector with missing data
        x
        is.na(x) # Does x have NAs? Yes
        which(is.na(x)) # NAs are in positions 5 and 8
        mean(x) # It doesn't work, why?
        mean(x, na.rm = TRUE) # Mean of x, without the NAs
        x[is.na(x)] # Extract positions 5 and 8 (the TRUE ones) of x
        x[is.na(x)] <- mean(x, na.rm = TRUE) # *assign* `<-` the mean of x to the cells where we have NA values in x
        round(x, 1) # Round the values of x and give me only 1 decimal point
        x # x still has a lot of decimal points. Why?
```
> Note that some people code NA as 99. If you feed these type of data to R, R won't know those are NAs.

Example of a data frame that codes missing values as 99
```{r, echo = TRUE}
df <- data.frame(col1 = c(1:3, 99), col2 = c(2.5, 4.2, 99, 3.2))
df
```

Change 99s to NAs
```{r, echo = TRUE}
df[df == 99] <- NA # in the locations that df== 99, insert an NA
df
```

**Exercise 7**: Create another column for family_df called salary where you give a salary to each family member, except to the dog.
```{r, echo = TRUE}
family_df$salary <- c(1500, 1350, 23, NA)
```

This family loves their dog and they dedicate 1% of their overall mean salary to him. Recode the salary missing value of the dog with 0.01 of the mean of the family's salary.
```{r, echo = TRUE}
family_df$salary[is.na(family_df$salary)] <- mean(family_df$salary, na.rm = TRUE) * 0.01
family_df
```

Get incomplete cases with the `!` operator
```{r, echo = TRUE}
family_df[!complete.cases(family_df),]
```

> End of Exercise 7

There are some other ocasions when R will return NA (or error, or warning):
Run these and see what happens
`var (8)`                                 # Variance of one number
`as.numeric (c("1", "2", "three", "4"))`   # Illegal conversion
`c(1, 2, 3)[4]`                           # Vector subscript out of range                   
`NA - 1`                                   # Most operations on NAs produce NAs
`a <- data.frame (a = 1:3, b = 2:4)`
`a[4,]`                                    # Data frame row subscript out of range. # The first NA in the output is the row number
`a[,4]`                                    # Specifying a non-existent column just produces an error


